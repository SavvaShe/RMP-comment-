//s:array[#21..'''',#32..#87,dfghjk] of (dfghj,dfghjk,dfghj); - > true
//s:array['''..'''',#32..#87,dfghjk] of (dfghj,dfghjk,dfghj); -> false
// Программа проверки правильности описания массива, у которого индексы могут иметь тип-название (например, boolean), ограниченный
//тип (для char), а тип-элемента – перечислимый тип.
//^- начало строки,\s - пробед ,* от 0 и до бесконечности, + от 1 и выше,одиночный \ для экранирование для спец символов,[] - диапазон,. - любой одиночный символ
//
fun main() {//функция мейн
    val str = readLine() // с помощью val не изменяемая переменная в которую записываю то что чистаю с помощью функции readLine()
    if (str!=null) {//проверка если строка не нул то исполняю действие

        val res = Regex("^\\s*[A-Za-z_]+[A-Za-z0-9_]*\\s*" + //опять с val создаю переменную Regex - регулярное выражение  (механизм для поиска и замены текста)
                ":\\s*[Aa][Rr][Rr][Aa][Yy]"+
                "\\s*\\[(([A-Za-z_]+[A-Za-z0-9_]*)|(((['][^']['])|([']['][']['])|(#[0-9]+))\\s*\\.\\.\\s*((['][^']['])|([']['][']['])|(#[0-9]+))))"+
                "(\\s*,\\s*(([A-Za-z_]+[A-Za-z0-9_]*)|(((['][^']['])|([']['][']['])|(#[0-9]+))\\s*\\.\\.\\s*((['][^']['])|([']['][']['])|(#[0-9]+)))))*\\s*\\]"+
                "\\s*[oO][fF]\\s*\\(([A-Za-z_]+[A-Za-z0-9_]*)(\\s*,\\s*[A-Za-z_]+[A-Za-z0-9_]*\\s*)*\\)"+
                "\\s*;\\s*") //валидация(сама проверка)
        println(res.matches(str))//вывожу результат с мопощью метода matсhes который сообщает, соответствует  или нет введенная строка  регулярному выражению res
    }else println("Неверно введена строка")// если мы провалили иф то идем сюда и выводим сообщение

}
